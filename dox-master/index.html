<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.9.2"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>ttg: ttg</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">ttg 0.1.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Overview</span></a></li>
      <li><a href="userguide.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer&#160;Guides</span></a></li>
      <li><a href="usergroup1.html"><span>Source&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ttg </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> <img src="https://github.com/TESSEorg/ttg/workflows/CMake/badge.svg" alt="Build Status" style="pointer-events: none;" class="inline"/></p>
<h1>TTG</h1>
<p >This is the C++ API for the Template Task Graph (TTG) programming model for flowgraph-based composition of high-performance algorithms executable on distributed heterogeneous computer platforms. The TTG API abstracts out the details of the underlying task and data flow runtime; the current realization is implemented using <a href="https://github.com/m-a-d-n-e-s-s/madness">MADNESS</a> and <a href="https://bitbucket.org/icldistcomp/parsec.git">PaRSEC</a> runtimes as backends.</p>
<h1>Why TTG?</h1>
<ul>
<li>TTG marries the idea of flowgraph programming models with the key innovations in the PARSEC runtime for compact specification of DAGs (PTG).</li>
<li>TTG can be used to efficiently compose and execute irregular computation patterns which are poorly served by the current programming and execution models.</li>
<li>TTG has strong support for distributed hybrid architectures for running modern scientific algorithms efficiently on current and near-future supercomputers.</li>
</ul>
<h1>Installation</h1>
<ul>
<li>To try out TTG in a Docker container, install Docker, then execute <code>bin/docker-build.sh</code> and follow instructions in <code>bin/docker.md</code>;</li>
<li>See <a href="https://github.com/TESSEorg/ttg/blob/master/INSTALL.md">INSTALL.md</a> to learn how to build and install TTG.</li>
</ul>
<h1>Key Concepts of TTG</h1>
<ul>
<li><code>TaskId</code> (aka <code>Key</code>): A unique identifier for each task. It should be hashable. For example, if computing a matrix multiplicaion, TaskId could be a triplet of integers identifying the tiles being operated upon.</li>
<li><code>Terminal</code>: Input and output arguments are exposed by the runtime as terminals. Input terminal is a single assignment variable and is used by the runtime to determine when arguments of a task are available. An input terminal is programmable. For example, it could perform a reduction operation.</li>
<li><code>Edge</code>: An output terminal is connected to the input terminal using edges. Multiple edges can connect to an input terminal enabling data to come from multiple sources and an output terminal might connect to multiple successors implying a broadcast operation.</li>
<li><code>TemplateTask</code> (aka <code>TT</code>): This is a <em>template</em> for creating tasks; its member function <code>op</code> defined the body of the task. It is typically created by wrapping a user-defined callable (free function or a lambda) with informal signature <code>void(TaskId, Arg0, Arg1, ..., OutputTerminals)</code> with <code>make_tt</code>. Task template is used to create a task for a given <code>TaskId</code> when all input data for the given <code>TaskId</code> have been received.</li>
</ul>
<h1>How to write a simple TTG program?</h1>
<ol type="1">
<li><p class="startli">Select the default TTG backend and include the required header files. To select the default backend define one (and only one) of the following macros, best via the command-line argument to the compiler or as an explicit <code>#define</code> statement:</p><ul>
<li><code>TTG_USE_PARSEC</code>: selects the PaRSEC backend as the default;</li>
<li><code>TTG_USE_MADNESS</code>: selects the MADNESS backend as the default (expert-use only).</li>
</ul>
<p class="startli">For simple programs it is sufficient to include the top-level header file: ```cpp #include &lt;ttg.h&gt; ``<code> It is also possible to hardwire the backend selection by including the corresponding backend-specific header directly; there is no need to</code>#include` the top-level TTG header or to define the backend selection macros:</p><ul>
<li>to use PaRSEC backend only, add: ```cpp #include &lt;<a class="el" href="ttg_2parsec_2ttg_8h_source.html">ttg/parsec/ttg.h</a>&gt; ```</li>
<li>to use the MADNESS backend only, add: ```cpp #include &lt;<a class="el" href="ttg_2madness_2ttg_8h_source.html">ttg/madness/ttg.h</a>&gt; ```</li>
</ul>
</li>
<li>Define a TaskId (Key) class which represents a unique identifier for each task and which is hashable.</li>
<li><p class="startli">Define a factory that returns a TemplateTask for every function that runs the computation. Below factory function returns a TemplateTask for recursively exploring the wavefronts of the Smith Waterman algorithm. The code adopts several common design motifs of a TTG program. Complete implementation of the algorithm can be found in the <a href="examples/">examples</a> directory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> funcT, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> make_sw1(<span class="keyword">const</span> funcT&amp; func, <span class="keywordtype">int</span> block_size, <span class="keyword">const</span> std::string &amp;a, <span class="keyword">const</span> std::string &amp;b,</div>
<div class="line">              <span class="keywordtype">int</span> problem_size, ttg::Edge&lt;Key, BlockMatrix&lt;T&gt;&gt;&amp; leftedge, ttg::Edge&lt;Key, BlockMatrix&lt;T&gt;&gt;&amp; topedge,</div>
<div class="line">              ttg::Edge&lt;Key, BlockMatrix&lt;T&gt;&gt;&amp; diagedge, ttg::Edge&lt;Key, T&gt;&amp; resultedge) {</div>
<div class="line">   <span class="keyword">auto</span> f = [block_size, problem_size, a, b, func](<span class="keyword">const</span> Key&amp; key, BlockMatrix&lt;T&gt;&amp;&amp; toporleft,</div>
<div class="line">               std::tuple&lt;ttg::Out&lt;Key, BlockMatrix&lt;T&gt;&gt;, ttg::Out&lt;Key, BlockMatrix&lt;T&gt;&gt;,</div>
<div class="line">               ttg::Out&lt;Key, BlockMatrix&lt;T&gt;&gt;, ttg::Out&lt;Key, BlockMatrix&lt;T&gt;&gt;, ttg::Out&lt;Key, T&gt;&gt;&amp; out) {</div>
<div class="line">     <span class="comment">// Getting the block coordinates</span></div>
<div class="line">     <span class="keyword">auto</span>[i, j] = key;</div>
<div class="line">     <span class="keywordtype">int</span> next_i = i + 1;</div>
<div class="line">     <span class="keywordtype">int</span> next_j = j + 1;</div>
<div class="line">     <span class="keywordtype">int</span> num_blocks = problem_size / block_size;</div>
<div class="line"> </div>
<div class="line">     BlockMatrix&lt;T&gt; X(block_size, block_size);</div>
<div class="line">     <span class="keywordflow">if</span> (i == 0 &amp;&amp; j == 0) {</div>
<div class="line">       <span class="comment">//No top, left or diagonal blocks</span></div>
<div class="line">       X = sw_iterative(i, j, X, X, X, X, block_size, a, b, problem_size);</div>
<div class="line">     }</div>
<div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == 0) {</div>
<div class="line">       <span class="comment">//Only left block, single dependency</span></div>
<div class="line">       X = sw_iterative(i, j, X, toporleft, X, X, block_size, a, b, problem_size);</div>
<div class="line">     }</div>
<div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j == 0) {</div>
<div class="line">       <span class="comment">//Only top block, single dependency</span></div>
<div class="line">       X = sw_iterative(i, j, X, X, toporleft, X, block_size, a, b, problem_size);</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">//std::cout &lt;&lt; X &lt;&lt; std::endl;</span></div>
<div class="line">     <span class="keywordflow">if</span> (next_i &lt; num_blocks) {</div>
<div class="line">       <span class="comment">//std::cout &lt;&lt; &quot;left &quot; &lt;&lt; next_i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; std::endl;</span></div>
<div class="line">       <span class="keywordflow">if</span> (j == 0)  <span class="comment">// send top block for next block computation</span></div>
<div class="line">         ttg::send&lt;0&gt;(Key(next_i, j), X, out);</div>
<div class="line">       <span class="keywordflow">else</span>  <span class="comment">// send top block for next block computation</span></div>
<div class="line">         ttg::send&lt;2&gt;(Key(next_i, j), X, out);</div>
<div class="line">     }</div>
<div class="line">     <span class="keywordflow">if</span> (next_j &lt; num_blocks) {</div>
<div class="line">       <span class="keywordflow">if</span> (i == 0)  <span class="comment">// send left block for next block computation</span></div>
<div class="line">         ttg::send&lt;0&gt;(Key(i, next_j), X, out);</div>
<div class="line">       <span class="keywordflow">else</span>  <span class="comment">// // send left block for next block computation</span></div>
<div class="line">         ttg::send&lt;1&gt;(Key(i, next_j), X, out);</div>
<div class="line">     }</div>
<div class="line">     <span class="keywordflow">if</span> (next_i &lt; num_blocks &amp;&amp; next_j &lt; num_blocks) {</div>
<div class="line">       ttg::send&lt;3&gt;(Key(next_i, next_j), X, out); <span class="comment">//send diagonal block for next block computation</span></div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     <span class="keywordflow">if</span> (i == num_blocks - 1 &amp;&amp; j == num_blocks - 1)</div>
<div class="line">       ttg::send&lt;4&gt;(Key(i,j), X(block_size-1, block_size-1), out);</div>
<div class="line">   };</div>
<div class="line"> </div>
<div class="line">   ttg::Edge&lt;Key, BlockMatrix&lt;T&gt;&gt; recur(<span class="stringliteral">&quot;recur&quot;</span>);</div>
<div class="line">   <span class="keywordflow">return</span> ttg::make_tt(f, ttg::edges(recur), ttg::edges(recur, leftedge, topedge, diagedge, resultedge), <span class="stringliteral">&quot;sw1&quot;</span>, {<span class="stringliteral">&quot;recur&quot;</span>},</div>
<div class="line">                       {<span class="stringliteral">&quot;recur&quot;</span>, <span class="stringliteral">&quot;leftedge&quot;</span>, <span class="stringliteral">&quot;topedge&quot;</span>, <span class="stringliteral">&quot;diagedge&quot;</span>, <span class="stringliteral">&quot;resultedge&quot;</span>});</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli">Define the edges and verify that the graph is connected in the main program.</p>
<div class="fragment"><div class="line">ttg::initialize(argc, argv, -1);</div>
<div class="line"> </div>
<div class="line">ttg::Edge&lt;Key, BlockMatrix&lt;int&gt;&gt; leftedge, topedge, diagedge;</div>
<div class="line">ttg::Edge&lt;Key, int&gt; resultedge;</div>
<div class="line"><span class="keyword">auto</span> s = make_sw1(sw_iterative&lt;int&gt;, block_size, a, b, problem_size, leftedge, topedge,</div>
<div class="line">                  diagedge, resultedge);</div>
<div class="line"><span class="keyword">auto</span> s1 = make_sw2(sw_iterative&lt;int&gt;, block_size, a, b, problem_size, leftedge, topedge,</div>
<div class="line">                  diagedge, resultedge);</div>
<div class="line"><span class="keyword">auto</span> r = make_result(verify, val1, resultedge);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> connected = <a class="code hl_function" href="namespacettg.html#ae59ab0f328195d1579a67a07d7870cc9">ttg::make_graph_executable</a>(s.get());</div>
<div class="line">assert(connected);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Graph is connected.\n&quot;</span>;</div>
<div class="ttc" id="anamespacettg_html_ae59ab0f328195d1579a67a07d7870cc9"><div class="ttname"><a href="namespacettg.html#ae59ab0f328195d1579a67a07d7870cc9">ttg::make_graph_executable</a></div><div class="ttdeci">std::enable_if_t&lt;(std::is_convertible_v&lt; std::remove_const_t&lt; std::remove_reference_t&lt; TTBasePtrs &gt; &gt;, TTBase * &gt; &amp;&amp;...), bool &gt; make_graph_executable(TTBasePtrs &amp;&amp;... ops)</div><div class="ttdef"><b>Definition:</b> <a href="func_8h_source.html#l00053">func.h:53</a></div></div>
</div><!-- fragment --></li>
<li><p class="startli">Execute the graph.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="namespacettg.html#a78c09561304884c05c8a8f25006b0ee6">ttg::default_execution_context</a>().rank() == 0)</div>
<div class="line">  s-&gt;in&lt;0&gt;()-&gt;send(Key(0,0), BlockMatrix&lt;int&gt;());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a>();</div>
<div class="line"><a class="code hl_function" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a>();</div>
<div class="ttc" id="anamespacettg_html_a1261c57f70c978771f64af07d7f7d7cd"><div class="ttname"><a href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a></div><div class="ttdeci">void execute(ttg::World world)</div><div class="ttdoc">Starts the execution in the given execution context.</div><div class="ttdef"><b>Definition:</b> <a href="run_8h_source.html#l00054">run.h:54</a></div></div>
<div class="ttc" id="anamespacettg_html_a78c09561304884c05c8a8f25006b0ee6"><div class="ttname"><a href="namespacettg.html#a78c09561304884c05c8a8f25006b0ee6">ttg::default_execution_context</a></div><div class="ttdeci">World default_execution_context()</div><div class="ttdoc">Accesses the default backend's default execution context.</div><div class="ttdef"><b>Definition:</b> <a href="run_8h_source.html#l00048">run.h:48</a></div></div>
<div class="ttc" id="anamespacettg_html_a807bf42719a82b1539603d477aa2a3fd"><div class="ttname"><a href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a></div><div class="ttdeci">void fence(ttg::World world)</div><div class="ttdoc">Returns when all tasks associated with the given execution context have finished on all ranks.</div><div class="ttdef"><b>Definition:</b> <a href="run_8h_source.html#l00061">run.h:61</a></div></div>
</div><!-- fragment --></li>
</ol>
<h2>Task Graph Visualization</h2>
<p >The task graph can be dumped into a DOT format using the below code in the main program after connecting the graph. <a href="https://www.graphviz.org/">GraphViz</a> tools can be used to visualize the task graph.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;==== begin dot ====\n&quot;</span>;</div>
<div class="line">std::cout &lt;&lt; <a class="code hl_class" href="classttg_1_1_dot.html">ttg::Dot</a>()(s.get()) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;==== end dot ====\n&quot;</span>;</div>
<div class="ttc" id="aclassttg_1_1_dot_html"><div class="ttname"><a href="classttg_1_1_dot.html">ttg::Dot</a></div><div class="ttdoc">Prints the graph to a std::string in the format understood by GraphViz's dot program.</div><div class="ttdef"><b>Definition:</b> <a href="dot_8h_source.html#l00012">dot.h:12</a></div></div>
</div><!-- fragment --><p >Below is a TTG graph generated by Smith Waterman algorithm. Each operation/TemplateTask factory is denoted by a rectangle with input terminals on the top and output terminals listed on the bottom part of the rectangle.</p>
<p ><img src="sw-df.png" alt="" class="inline"/></p>
<h1>TTG reference documentation</h1>
<p >TTG API documentation is available for the following versions:</p><ul>
<li><a href="https://tesseorg.github.io/ttg/dox-master">master branch</a> .</li>
</ul>
<h1>Cite</h1>
<p >When referring to TTG in an academic setting please cite the following publication:</p><ul>
<li>G. Bosilca, R. J. Harrison, T. Herault, M. M. Javanmard, P. Nookala and E. F. Valeev, "The Template Task Graph (TTG) - an emerging practical dataflow programming paradigm for scientific simulation at extreme scale," 2020 IEEE/ACM Fifth International Workshop on Extreme Scale Programming Models and Middleware (ESPM2), 2020, pp. 1-7, doi: <a href="https://dx.doi.org/10.1109/ESPM251964.2020.00011">10.1109/ESPM251964.2020.00011</a>.</li>
</ul>
<h1>Acknowledgment</h1>
<p >The development of TTG was made possible by:</p><ul>
<li><a href="https://tesseorg.github.io/">The EPEXA project</a>, currently supported by the National Science Foundation under grants <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1931387">1931387</a> at Stony Brook University, <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1931347">1931347</a> at Virginia Tech, and <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1931384">1931384</a> at the University of Tennesse, Knoxville.</li>
<li>The TESSE project, supported by the National Science Foundation under grants <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1450344">1450344</a> at Stony Brook University, <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1450262">1450262</a> at Virginia Tech, and <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1450300">1450300</a> at the University of Tennesse, Knoxville. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Sun Nov 14 2021 12:36:22 for <a href="https://https://github.com/ValeevGroup/tiledarray/">ttg</a>
    0.1.0 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.2
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
